# Rust Quiz 解读：Quiz 8

### Quiz 8: 

下面这段代码输出什么？

```rust
macro_rules! m {
    (==>) => { print!("1"); };
    (= = >) => { print!("2"); };
    (== >) => { print!("3"); };
    (= =>) => { print!("4"); };
}

fn main() {
    m!(==>);
    m!(= = >);
    m!(== >);
    m!(= =>);
}
```

**输出结果: 1214**

### 解读

考察要点：

1. `macro_rules!`定义宏匹配规则
2. 理解词法分析中的token
3. 操作符优先级

Rust中使用`macro_rules!`来定义声明宏，将来也会稳定`macro`关键字。但基本的核心是不变的。Rust语言因为还在发展期，所以无法像其他很多语言一样，把AST（抽象语法树）暴露出来给开发者使用。导致现在Rust的宏，都是基于分词解析后形成的词条流（TokenStream）来编写宏。

所以，你可以把声明宏理解为是TokenStream模板。其实声明宏也有另外一个名字：「macro by example」

声明宏的语法规则是这样的：

```rust
macro_rules! $name {
    $rule0 ;
    $rule1 ;
    // …
    $ruleN ;
}
```

一个声明宏里可以包含多个规则（$rule）。一般来说，声明宏的时候，规则模式经常使用下面的标识符来匹配对应的项：

```
item: 条目，比如函数、结构体、模组等。
block: 区块(即由花括号包起的一些语句加上/或是一项表达式)。
stmt: 语句
pat: 模式
expr: 表达式
ty: 类型
ident: 标识符
path: 路径 (例如 foo, ::std::mem::replace, transmute::<_, int>, …)
meta: 元条目，即被包含在 #[...]及#![...]属性内的东西。
tt: 标记树
```

比如在Quiz 1中见到的：

```rust
macro_rules! m {
    ($($s:stmt)*) => {
        $(
            { stringify!($s); 1 }
        )<<*
    };
}
```


其中`$s:stmt`表示匹配一个语句。而Quiz 8中声明的这个宏，其匹配规则并没有使用任何标识符。而是直接使用了`==>`或`= = >`这样的值，这叫做`token字面量`。它表示，Rust编译器中的宏解释器会把它作为token进行匹配。


所以，在上面Quiz 8的代码中，定义声明宏`m!`，包含了四个匹配模式。

`(==>)`，表示要直接和分词得到的token流进行匹配，那么它能匹配的是两个token：`==`和`>`。因为是从左往右进行匹配。在Rust中，`==`是一个完整的token。但是有的人可能会想，为什么不是匹配成`=`和`=>`呢？这是因为在Rust里`==`（ 比较操作符）的优先级要高于`=`（赋值操作符）。所以，在执行`m!(==>);`的时候，输出：1。

`(= = >)`，那么同理，匹配`=`、`=`和`>`。注意匹配模式中包含的空格是忽略不计的，空格的作用，其实就是为了帮助编译器识别如何「断句」。所以，在执行`m!(= = >)`的时候，当然输出： 2。

`(== >)`，其实和`(==>)`是一样的。不一样的是它们在宏定义中出现的位置。这里执行`m!(== >);`输出是：1。这个差别待会再解释。

`(= =>);`，同理，匹配`=`和`=>`，所以在执行`m!(= =>);`的时候，输出：4。

最终结果是：`1214`。

*那么，为什么`m!(== >);`无法输出 3 呢？*

我们把代码修改一下：

```rust
macro_rules! m {
    (== >) => { print!("3"); };
    (= = >) => { print!("2"); };
    (==>) => { print!("1"); };
    (= =>) => { print!("4"); };
}
fn main() {
    m!(==>);
    m!(= = >);
    m!(== >);
    m!(= =>);
}
```

修改后的输出结果： `3234`。

注意，我只是把`(== >)`和`(==>)`的匹配分支顺序换了一下。这段代码中，说明了声明宏的另一个特性：优先匹配最前面的匹配分支。

因为`m!(==>);`的默认分词匹配就是`==`和`>`，所以，当碰到第一个匹配分支`(== >)`的时候，就匹配到了，所以，不会继续寻找后面的匹配分支，所以，不可能输出： `1`。同理，回到修改前的代码中，`m!(== >);`最先匹配的是`(==>)`，所以不可能再去寻找后面的匹配分支了，所以不可能输出: `3`。


[点此查看 Rust Quiz 8](https://dtolnay.github.io/rust-quiz/8)