# Rust Quiz 解读：Quiz 12

### Quiz 12: 

下面这段代码输出什么？

```rust
struct D(u8);

impl Drop for D {
    fn drop(&mut self) {
        print!("{}", self.0);
    }
}

struct S {
    d: D,
    x: u8,
}

fn main() {
    let S { x, .. } = S {
        d: D(1),
        x: 2,
    };
    print!("{}", x);

    let S { ref x, .. } = S {
        d: D(3),
        x: 4,
    };
    print!("{}", x);
}
```


**输出结果： 1243**

### 考察要点

1. let绑定时，结构体模式匹配
2. ref 模式匹配
3. 析构顺序

Quiz代码中定义了单元结构体`D(u8)`，并且为其实现了Drop。这意味着，在`D(u8)`出了作用域会自动调用其实现的`drop`方法。

然后定义了结构体S，两个字段其中一个类似是`D`。这就意味着，该结构体实例被销毁时，会调用字段`d`的`drop`方法。

在main函数中，使用let绑定模式匹配解构一个结构体实例。

```rust
let S { x, .. } = S {
    d: D(1),
    x: 2,
};
```

上面代码相当于定义了`let x = 2;` ，而结构体实例中`d: D(1)`字段将会被抛弃，因为它没有绑定任何变量。 所以，此时输出`x`的值为： 2。

```rust
let S { ref x, .. } = S {
    d: D(3),
    x: 4,
};
```

同理，上面代码的`d: D(3)`同样会被抛弃。相当于`let ref x = 4;`，等价于`let x = &4;`。所以，此时输出`x`的值为： `4`。

但为什么输出结果顺序是：`1 -> 2 -> 4 -> 3`呢？

我们为Quiz代码中的结构体`S`实现一个Drop。

```rust
impl Drop for S {
    fn drop(&mut self) {
        print!("S");
    }
}
```

然后再执行Quiz代码，输出结果是： `S124S3`。

从这个结果中发现：

最先析构的是结构体S的第一个实例，其次是`d: D(1)`，第三个是结构体S的另一个实例，最后是`d: D(3)`。

两个结构体实例先于`D(1)`和`D(3)`析构，是因为它们是先声明的。但是为什么输出结果不是`S12S34`呢？

继续修改Quiz代码：

```rust
 let S {  x, .. } = S {
        d: D(3),
        x: 4,
    };
```

把main函数中第二个结构体实例的let绑定中的`ref`去掉了。输出结果是：`S12S34`。

看来，是这个`ref`影响了析构的顺序。回到原始的Quiz代码中，来分析这个过程：

1. 第一个结构体实例最先被声明，但该实例本身也没有被绑定任何变量。所以它第一个被弃用。调用其drop方法输出：`S`。
2. 第二个被析构的是`D(1)`，同理，因为它没有绑定任何变量，此时已无用。调用其drop方法输出：`1`。
3. 此时结构体中x字段已经绑定给了x变量，打印输出它的值： `2`。
4. 第三个被析构的是第二个结构体S的实例。理论上，它没有绑定任何变量。所以应该调用其drop方法输出：`S`。但是，此时let绑定解构语句中使用了`ref`，它是一种模式匹配操作，将该结构体实例的字段`x`的引用匹配了出来，相当于`let x = &S{x: 4}.x`。也就是说，此时的绑定`x`，是对结构体实例中字段的引用，如果此时抛弃了该结构体实例，势必会造成悬垂指针。所以，这里直接输出打印x的值：`4`。
5. 在使用完`x`之后，结构体实例可以被析构了，调用drop，然后输出：`S`。
6. 最后在对`D(3)`析构，输出：`3`。

那么最终结果就是： `S124S3`。对于原始Quiz代码来说，输出结果就是：`1243`。


[点此查看 Rust Quiz 12](https://dtolnay.github.io/rust-quiz/12)


