# Rust Quiz 解读：Quiz 4

### Quiz 4: 

下面这段代码输出什么？

```rust
fn main() {
    let (.., x, y) = (0, 1, ..);
    print!("{}", b"066"[y][x]);
}
```

**输出结果： 54**

### 解读：

考察要点： 

1. 模式匹配
2. Range和RangeFull
3. 字节字符串表示法

上面只有两行代码，但是隐藏了很多信息。

Rust中let绑定语句支持模式匹配。main函数中代码第一行是元组的匹配赋值操作。在等号左边的`(.., x, y)`是匹配的模式，等号右边`(0, 1, ..)`是要匹配的值。

这里最迷惑人的地方就是`..`，在匹配模式中，`..`代表其余要匹配的项。在上面示例中，就是除了x和y之外，要匹配的项。而在等号右边等待匹配的值中，`..`则代表一个值：RangeFull。RangeFull是一个单元结构体，它代表Range（范围）的全范围类型。

所以，下面代码是合法的：

```rust
let range_full = std::ops::RangeFull;
let range_full = ..;
```

这两行代码是等价的。

所以，上面最终的元组匹配结果是：

1. 左边`..`匹配右边的`0`
2. 左边`x`匹配右边的`1`
3. 左边`y`匹配右边的`..`

然后在最后的`print!`语句中，`b"0666"`实际上是一种字节字符串的语法糖，它等价于`[48u8, 54u8, 54u8]`字节序列：

```rust
 let d = [48u8, 54u8, 54u8];
 assert_eq!("066", std::str::from_utf8(&d).unwrap());
```

所以，`b"066"[y][x]`现在是`b"066"[..][1] == b"6"`，那么最终输出结果就是： 54。

[点此查看Rust Quiz 4](https://dtolnay.github.io/rust-quiz/4)