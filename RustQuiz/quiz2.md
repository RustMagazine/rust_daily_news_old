# Rust Quiz 解读： Quiz 2

### Quiz 2: 

下面这段代码输出什么？

```rust
struct S(i32);

impl std::ops::BitAnd<S> for () {
    type Output = ();

    fn bitand(self, rhs: S) {
        print!("{}", rhs.0);
    }
}

fn main() {
    let f = || ( () & S(1) );
    let g = || { () & S(2) };
    let h = || ( {} & S(3) );
    let i = || { {} & S(4) };
    f();
    g();
    h();
    i();
}
```


**输出结果：123**

### 解读：

考察要点： 

1. trait：操作符重载
2. trait：关联类型
3. 单元类型 ()
4. 元组结构体
5. 闭包使用圆括号和块的差异

代码中定义了元组结构体S(i32)，又为其实现了`std::ops::BitAdd<s>` trait，意味着，该元组结构体就有了位运算`&`的能力。

在实现BitAdd的代码中，指定了关联类型为单元类型`()`，在bitand方法中，省略了返回类型。等价于下面代码。

```
fn bitand(self, rhs: S) -> () { ... }
```

那么在main函数中：

`let f = || ( () & S(1) );`  ， 这行代码中，f绑定的是一个闭包。闭包中`() & S(1)`是一个位操作`&`表达式。最终结果当然是输出`rhs.0`，也就是：1。元组结构体和元组的用法是一样的。

`let g = || { () & S(2) };`， 这行代码中，g绑定的依然是一个闭包。闭包可以用圆括号，也可以用花括号。闭包内，`() & S(2)`依然是一个完整的表达式，求值结果是：2。

` let h = || ( {} & S(3) );`，这行代码中，h同样是一个闭包，但注意这里闭包是用圆括号来表示，这代表，`{} & S(3)`按一个完整独立的表达式来处理。其中`{}`表达式求值结果是`()`，再和`S(3)`进行与操作，得到最终值： 3。

`let i = || { {} & S(4) };`，这行代码中， i同样是一个闭包，然而，它是以花括号构成。花括号和圆括号的区别在于，花括号代表一个块（block），它默认按多条表达式语句进行解析。所以，`{} & S(4)`，实际上被看作两条语句`{}`和`&S(4)`，最终闭包执行结果是返回一个`S(4)`的引用。和位操作没有啥关系，最终也没有任何输出结果。

`()`和`{}`的区别，不仅仅在于闭包，在写声明宏或者其他地方都是一致的。

[点此查看 Rust Quiz 2 ](https://dtolnay.github.io/rust-quiz/2)