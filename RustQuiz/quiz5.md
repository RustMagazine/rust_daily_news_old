# Rust Quiz 解读：Quiz 5

### Quiz 5: 

下面这段代码输出什么？

```rust
trait Trait {
    fn f(self);
}

impl<T> Trait for fn(T) {
    fn f(self) {
        print!("1");
    }
}

impl<T> Trait for fn(&T) {
    fn f(self) {
        print!("2");
    }
}

fn main() {
    let a: fn(_) = |_: u8| {};
    let b: fn(_) = |_: &u8| {};
    let c: fn(&_) = |_: &u8| {};
    a.f();
    b.f();
    c.f();
}
```


**输出结果：112**

### 解读：

考察要点： 

1. fn(T)与fn(&T)的区别
2. 类型推断
3. trait 实现

代码中定义了一个名为`Trait`的trait，其中包含了方法签名`f`。然后分别为`fn(T)`和`fn(&T)`这两种函数指针类型实现了Trait。

那`T` 和`&T`有啥区别呢？

- [ ] T， 是一个泛型参数，代表任何一个具体的类型。那么`fn(T)`就是指一个拥有具体类型的函数指针。
- [ ] &T，实际上等价于`&'a T`，代表某个引用类型。则`fn(&T)`，就是`fn(&'a T)`。注意这里的`'a`也是一个泛型参数，并不是指具体的类型。

在main函数中，分别定义了三个变量绑定，a、b、c，分别将三个闭包指定为特定的函数指针类型。最后再分别调用它们的`f`方法。

`let a: fn(_) = |_: u8| {};`，对于`a`来说，`_`会被推断为`u8`类型。那么对应于`fn(T)`类型，最终调用其f方法输出结果就是：1。

`let b: fn(_) = |_: &u8| {};`，对于`b`来说，`_`会被推断为`&u8`类型。这就是一个令人迷惑的点了，到底是对应`fn(T)`还是`fn(&T)`。这里的`&u8`实际上是一个具体的值。它实际上等价于`f(&'x u8)`，这里的`'x`是一个具体的可确定的生命周期值。因为Rust生命周期参数，只有在具体使用的地方，才是具体实例化的。最终调用其f方法输出结果依然是：1。

let c: fn(&_) = |_: &u8| {};``，对于c来说，`_`会被推断为`u8`。此时显然，对应于`fn(&T)`。`&u8`的生命周期固然是已经具体实例化，但它的函数指针类型，依然是`fn(&T)`。最终调用其方法输出结果就是： 2。

[点此查看 Rust Quiz 5](https://dtolnay.github.io/rust-quiz/5)

